1.斐波那契数列  https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking
递归：public class Solution {
    public int Fibonacci(int n) {
        if(n < 2) return n;
        return Fibonacci(n-1) + Fibonacci(n-2);
    }
}
非递归：public class Solution {
    public int Fibonacci(int n) {
        if(n<2) return n;
        int pre = 0;
        int cur = 1;
        int sum = 0;
        for(int i=2;i<=n;i++){
            sum = cur + pre;
            pre = cur;
            cur = sum;
        }
        return sum;
    }
}

2.矩形覆盖 https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking
public class Solution {
    public int RectCover(int target) {
        if(target == 0) return 0;
        if(target == 1) return 1;
        if(target == 2) return 2;
        return RectCover(target - 1) + RectCover(target - 2);
    }
}

3.跳台阶 https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking
public class Main {
    public int JumpFloor(int target) {
        if(target == 1){return 1;}
        if(target == 2){return 2;}
        return JumpFloor(target-1) + JumpFloor(target-2);
    }
}

4.变态跳台阶 https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking
等比数列
public class Solution {
    public int JumpFloorII(int target) {
        //if(target == 1) return 1;
        //return 2 * JumpFloorII(target - 1);
        return (int) Math.pow(2, target - 1);
    }
}

5.旋转数组的最小数字 https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking
(1)public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if(array == null || array.length == 0) return 0;
        for(int i=0;i<array.length-1;i++){
            if(array[i] > array[i+1]){
                return array[i+1];
            }
        }
        return array[0];
    }
}

(2)public int minNumberInRotateArray(int[] array) {
    if (array.length == 0)
        return 0;
    int l = 0, h = array.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (array[l] == array[m] && array[m] == array[h])
            return minNumber(array, l, h);
        else if (array[m] <= array[h])
            h = m;
        else
            l = m + 1;
    }
    return array[l];
}

private int minNumber(int[] array, int l, int h) {
    for (int i = l; i < h; i++)
        if (array[i] > array[i + 1])
            return array[i + 1];
    return array[l];
}

*6.矩阵中的路径 https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking
public class Solution {
    public boolean hasPath(char[] matrix, int rows, int cols, char[] str)
    {
        boolean[] visited = new boolean[rows * cols];
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                if(hasPathHelper(matrix,rows,cols,i,j,str,visited,0)) return true;
            }
        }
        return false;
    }
    
    private boolean hasPathHelper(char[] matrix,int rows,int cols,int i,int j,char[] str,
                                  boolean[] visited,int k){
        int index = i * cols + j;
        if(i<0 || i>=rows || j<0 || j>=cols || visited[index] || matrix[index] != str[k] 
           || k>=str.length) return false;
        visited[index] = true;
        if(k == str.length-1) return true;
        if(hasPathHelper(matrix,rows,cols,i-1,j,str,visited,k+1) || 
          hasPathHelper(matrix,rows,cols,i+1,j,str,visited,k+1) ||
          hasPathHelper(matrix,rows,cols,i,j+1,str,visited,k+1) ||
          hasPathHelper(matrix,rows,cols,i,j-1,str,visited,k+1)) return true;
        visited[index] = false;
        return false;
    }
}

7.机器人的运行范围 https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=4&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking
public class Solution {
    public int movingCount(int threshold, int rows, int cols)
    {
        boolean[][] visited = new boolean[rows][cols];
        return movingCountHelper(threshold,rows,cols,0,0,visited);
    }
    
    private int movingCountHelper(int threshold,int rows,int cols,int i,int j,boolean[][] visited){
        if(i<0 || i>=rows || j<0 || j>=cols || sum(i)+sum(j)>threshold || visited[i][j]) 
           return 0;
        visited[i][j] = true;
        return movingCountHelper(threshold,rows,cols,i+1,j,visited)
            + movingCountHelper(threshold,rows,cols,i-1,j,visited)
            + movingCountHelper(threshold,rows,cols,i,j+1,visited)
            + movingCountHelper(threshold,rows,cols,i,j-1,visited)+1;
    }
    
    private int sum(int t){
        int result = 0;
        while(t != 0){
            result = result + t % 10;
            t = t/10;
        }
        return result;
    }
}



