1.斐波那契数列  https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&tqId=11160&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking
递归：public class Solution {
    public int Fibonacci(int n) {
        if(n < 2) return n;
        return Fibonacci(n-1) + Fibonacci(n-2);
    }
}
非递归：public class Solution {
    public int Fibonacci(int n) {
        if(n<2) return n;
        int pre = 0;
        int cur = 1;
        int sum = 0;
        for(int i=2;i<=n;i++){
            sum = cur + pre;
            pre = cur;
            cur = sum;
        }
        return sum;
    }
}

2.矩形覆盖 https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&tqId=11163&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking
public class Solution {
    public int RectCover(int target) {
        if(target == 0) return 0;
        if(target == 1) return 1;
        if(target == 2) return 2;
        return RectCover(target - 1) + RectCover(target - 2);
    }
}

3.跳台阶 https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&tqId=11161&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking
public class Main {
    public int JumpFloor(int target) {
        if(target == 1){return 1;}
        if(target == 2){return 2;}
        return JumpFloor(target-1) + JumpFloor(target-2);
    }
}

4.变态跳台阶 https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&tqId=11162&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking
等比数列
public class Solution {
    public int JumpFloorII(int target) {
        //if(target == 1) return 1;
        //return 2 * JumpFloorII(target - 1);
        return (int) Math.pow(2, target - 1);
    }
}

5.旋转数组的最小数字 https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&tqId=11159&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking
(1)public class Solution {
    public int minNumberInRotateArray(int [] array) {
        if(array == null || array.length == 0) return 0;
        for(int i=0;i<array.length-1;i++){
            if(array[i] > array[i+1]){
                return array[i+1];
            }
        }
        return array[0];
    }
}

(2)public int minNumberInRotateArray(int[] array) {
    if (array.length == 0)
        return 0;
    int l = 0, h = array.length - 1;
    while (l < h) {
        int m = l + (h - l) / 2;
        if (array[l] == array[m] && array[m] == array[h])
            return minNumber(array, l, h);
        else if (array[m] <= array[h])
            h = m;
        else
            l = m + 1;
    }
    return array[l];
}

private int minNumber(int[] array, int l, int h) {
    for (int i = l; i < h; i++)
        if (array[i] > array[i + 1])
            return array[i + 1];
    return array[l];
}

